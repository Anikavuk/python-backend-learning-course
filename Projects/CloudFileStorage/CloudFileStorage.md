# Проект "облачное хранилище файлов"

Многопользовательское файловое облако. Пользователи сервиса могут использовать его для загрузки и хранения файлов. Источником вдохновения для проекта является Google Drive.

## Что нужно знать

- Java - коллекции, ООП
- Maven/Gradle
- Spring Boot, Spring Security, Spring Sessions
- Thymeleaf
- Базы данных - SQL, Spring Data JPA, представление о NoSQL хранилищах
- Веб - upload файлов, заголовки HTTP запросов, cookies, cессии
- HTML/CSS
- Docker на уровне запуска контейнеров

## Мотивация проекта

- Использование возможностей Spring Boot
- Практика с основами Docker
- Первый проект где студент самостоятельно разрабатывает структуру БД
- Знакомство с NoSQL хранилищами - S3 для файлов, Redis для сессий

## Функционал приложения

Работа с пользователями:

- Регистрация
- Авторизация
- Logout

Работа с файлами и папками:

- Загрузка файлов и папок
- Создание новой пустой папки (аналогично созданию новой папки в проводнике)
- Удаление
- Переименование

## Интерфейс приложения

### Главная страница

Адрес - `/?path=$path_to_subdirectory`. Параметр `$path` задаёт путь просматривамой папки. Если параметр отсутствует, подразумевается корневая папка. Пример - `/path=Projects%2FJava%2FCloudFileStorage` (параметр закодирован через URL Encode).

- Заголовок
    - Для неавторизованных пользователей - кнопки регистрации и авторизации
    - Для авторизованных пользователей - логин текущего пользователя и кнопка Logout
- Контент
    - Форма поиска файлов и папок по названию
    - Навигационная цепочка (breadcrumbs), содержащая путь из папок до текущей папки. Каждый элемент явлеятся ссылкой на свою папку. Пример - цепочка из папок, ведущая к - `Projects/Java/CloudFileStorage` содержала бы 3 папки - корневую, `Projects` и `Projects/Java`
    - Список файлов в текущей директории. Для каждого файла отображаем имя и кнопку, вызывающее меню действий (удаление, переименование)
    - Формы (или drop areas) для загрузки файлов и папок

### Страница поиска файлов

Адрес - `/search/?query=$search_query`.

- Заголовок
    - Для неавторизованных пользователей - кнопки регистрации и авторизации
    - Для авторизованных пользователей - логин текущего пользователя и кнопка Logout
- Контент
    - Форма поиска файлов и папок по названию
    - Список найденных файлов. Для каждого найденного файла отображаем имя и кнопку для перехода в папку, содержащую данный файл

### Контроллер для доступа к конкретному файлу

### Остальное

- Страницы с формами регистрации и авторизации

## Работа с сессиями, авторизацией, регистрацией

В предыдущем проекте мы управляли сессиями пользователей вручную, в этом проекте воспользуемся возможности экосистемы Spring Boot.

За авторизацию, управление доступом к страницам отвечает Spring Security.

За работу с сессиями отвечает Spring Sessions. По умолчанию Spring Boot хранит сессии внутри приложения, и они теряются после каждого перезапуска приложения. Мы воспользуемся Redis для хранения сессий. Пример - https://www.baeldung.com/spring-session. Redis - NoSQL хранилище, имеющее встроенный TTL (time to live) атрибут для записей, что делает его удобным для хранения сессий - истекшие сессии автоматически удаляются. 

## SQL база данных

В этом проекте студент самостоятельно разрабатывает структуру базы данных для хранения пользователей (файлы и сессии распологаются в других хранилищах).

Ориентироваться стоит на интеграцию с Spring Security. Эта библиотека экосистемы Spring подразумевает определённые атрибуты, которыми должен обладать пользователь, и список которых и станет основой колонок для таблицы `Users`.

Пример интеграции между Spring Security и Spring Data JPA - https://www.baeldung.com/registration-with-spring-mvc-and-spring-security.

Важно помнить о создании необходимых индексов в таблице `Users`. Например, логин пользователя должен быть уникальным.

## Хранилище файлов S3

Для хранения файлов будем пользоваться S3 - simple storage service. Проект, разработанный Amazon Cloud Services, представляет из себя облачный сервис и протокол для файлового хранилища. Чтобы не зависеть от платных сервисов Amazon в этом проекте, воспользуемся альтернативным S3-совместимым хранилищем, которое можно запустить локально - https://min.io/

- Докер образ для локального запуска MinIO - https://hub.docker.com/r/minio/minio/
- Для работы с протоколом S3 воспользуемся AWS Java SDK, пример - https://docs.min.io/docs/how-to-use-aws-sdk-for-java-with-minio-server.html

### Структура S3 хранилища

В SQL мы оперируем таблицами, в S3 таблиц не существует, вместо этого S3 оперирует бакетами (bucket - корзина) с файлами. Чтобы понять что такое бакет, можно провести аналогию с диском или флешкой.

Внутри бакета можно создавать файлы и папки.

Для хранения файлов всех пользователей в проекте создадим для них бакет под названием `user-files`. В корне бакета для каждого пользователя будет создана папка с именем в формате `user-${id}-files`, где `id` является идентификатором пользователя из SQL базы.

Каждая из таких папок является корнем для хранения папок данного пользователя. Пример - файл `docs/test.txt` пользователя с id `1` должен быть сохранён в путь `user-1-files/docs/test.txt`.

### Работа с S3 из Java

Как было упомянуто выше, для работы с S3 воспользуемся AWS Java SDK. Необходимо будет научиться пользоваться этот библиотекой, чтобы:
- Создавать файлы
- Переименовывать файлы
- "Переименовывать" папки. Насколько знаю в S3 нет такой операции, переименование папки по сути представляет собой создание папки под новым именем и перенос туда файлов
- Удалять файлы

## Upload файлов

Для загрузки файлов и папок необходимо воспользоваться HTML file input - https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file. Рапространённый подход оформить это в виде зоны, на которую можно перетягивать файлы из проводника, пример - https://codepen.io/dcode-software/pen/xxwpLQo.

На уровне HTTP, передача файлов осуществляется с помощью `multipart/form-data`.

Со стороны Spring Boot необходимо будет реализовать контроллер(ы) для обработки загруженных файлов. Важно иметь ввиду, что по-умолчанию лимит на загрузку файлов в Spring Boot равен 10 мегабайтам, но его можно увеличить.

## Docker

## План работы над приложением
